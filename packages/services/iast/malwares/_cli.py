import pathlib
import yara

from exlib.settings import osenv

from exlib.concurrent.context import WorkerResult
from exlib.log.logger import MyLogger
log = MyLogger.getLogger(__package__)  


def scan(context):
    try:
        data_path = str(osenv.appdata_path() / "resource" / "malwares" / "rules.dat") 
        rules = yara.load(data_path)
    except:
        log.exception(f"failed to load rules.data from {data_path}")
        return -1

    result = {}

    subfiles = context.metadata.get('subfiles', None)
    if not subfiles:
        return None

    for checksum, filedata in subfiles.items():
        filepath = context.version_path / filedata['filepath']

        if osenv.get_setting('MALWARE_SCAN_ALL', "no") != 'yes':
            filetype = filedata.get('filetype', "")
            if not filetype or not filetype.startswith(("code", "shared", "javaclass", "octet-stream", "executable", "kernelmod", "linux", "pe", "relocatable", "binary")):
                log.info(f"malware scan ignored {filetype}: {filepath}")
                continue
        
        if filepath.name.endswith(('.yar', '.yara')):
            continue
        
        malwares = {}
        with filepath.open('rb') as f:
            matches = rules.match(data=f.read())
        
            for match in matches:                
                tags = match.tags
                meta = match.meta
                strings = match.strings
                
                group = tags[0] if tags else match.rule
                rule = match.rule

                matched_data = {}
                for string in match.strings:
                    for instance in string.instances:
                        matched_data.setdefault(instance.matched_data, instance.offset)

                log.debug(f'{match} ## {group}, {rule}: {matched_data}')
                group_rule = f"{group} + {rule}"                
                malwares[group_rule] = dict(group=group, rule=rule, data="\n".join([f"Line {v}: {k}" for k,v in matched_data.items()]), desc=meta.get("description", ""))                

        result[checksum] = list(malwares.values())

    return WorkerResult(context, result)

if __name__=="__main__":
    from addict import Addict
    context = Addict({'checksum': '1143f3c7bd6ffa37cb02b7edcc0514cbe6829adb3690710e088fac8a8c0d993b',
                     'filepath': pathlib.Path('/data/nfs-data/PID20241103020747450106/VID20241104093757026087/emails-ips-urls.7z'),
                     'filepath_p': pathlib.Path('/data/nfs-data/PID20241103020747450106/VID20241104093757026087/_/root'),
                     'metadata': {'subfiles': {'6be626895ddc9bee1b5a728d8ab0492764b298a14234b714e7757ae1100cbd21': pathlib.Path('root/rel/emails-ips-urls/a.txt'),
                                               '79789c59decec048a1281db5b9ecfe59598dbb87d7090e23674c6b462aa6fa8e': pathlib.Path('root/rel/emails-ips-urls/leaks.c'),
                                               'a3b175cba882a92c1d7626d65b9082ba5106ce5ff5d4bc3a88ffa7c3cbad0df0': pathlib.Path('root/rel/emails-ips-urls/e.txt'),
                                               'a5c5bbf4ade26b51e1240ba73dc39ee0162bd0c28a54b37f124e90472c70f35f': pathlib.Path('root/rel/emails-ips-urls/b.txt'),
                                               'b472264f8b6ca072c71e836364a08c0dcc13ddb980b2f1c54d165006532cdb67': pathlib.Path('root/rel/emails-ips-urls/d.txt')}},
                     'pipeline_id': 'infoleak.0',
                     'pipeline_rules': [{'command': 'scan',
                                         'module': 'services.iast.malwares._cli'}],
                     'response_id': 'JOB/MALWARES',
                     'response_queue': ('sast.middlepri', 'sast.middlepri'),
                     'max_timeout': 120,
                     'max_memory': 25*(1024**3),
                     'version_id': 'VID20241104093757026087',
                     'version_path': pathlib.Path('/data/nfs-data/PID20241103020747450106/VID20241104093757026087/_')})

    r = scan(context)
    print(r)

